پاسخ به زبان فارسی و با فرمت Markdown برای GitHub ارائه شده است:

---

# یافتن مجموعه‌های پرتکرار با استفاده از الگوریتم A-Priori

این گزارش به تشریح و اجرای گام به گام **الگوریتم A-Priori** برای کشف **مجموعه‌های پرتکرار (frequent itemsets)** در یک مجموعه داده مدل "سبد خرید" می‌پردازد. هدف نهایی، شناسایی گروه‌هایی از اقلام است که به طور مکرر در تراکنش‌ها با یکدیگر ظاهر می‌شوند.

---

## مفاهیم کلیدی

* **مدل سبد خرید (Market-Basket Model):** داده‌ها شامل مجموعه‌ای از اقلام و مجموعه‌ای از سبدها (تراکنش‌ها) هستند که هر سبد زیرمجموعه‌ای از اقلام را دربرمی‌گیرد.
* **پشتیبانی (Support):** تعداد سبدهایی که شامل تمام اقلام یک مجموعه مشخص هستند. یک مجموعه اقلام زمانی **پرتکرار (frequent)** نامیده می‌شود که پشتیبانی آن حداقل به اندازه **آستانه پشتیبانی (minimum support threshold)** باشد.
* **آستانه پشتیبانی (min\_sup):** در این مسئله، `min_sup` برابر با **۶۰٪** تعیین شده است. از آنجایی که ۴ تراکنش وجود دارد، حداقل تعداد تکرار برای پرتکرار بودن یک مجموعه برابر با $4 \times 0.60 = 2.4$ است که به عدد صحیح **۳** گرد می‌شود.
* **اطمینان (Confidence):** (برای قوانین انجمن) احتمال شرطی که اگر یک سبد شامل مجموعه اقلام `I` باشد، شامل قلم `j` نیز خواهد بود. این مفهوم برای یافتن مجموعه‌های پرتکرار استفاده نمی‌شود و برای مرحله بعدی کشف قوانین انجمن کاربرد دارد.
* **خاصیت یکنوایی (Monotonicity Property):** اگر یک مجموعه اقلام `I` پرتکرار باشد، آنگاه هر زیرمجموعه آن `J ⊆ I` نیز پرتکرار است. این خاصیت پایه و اساس الگوریتم A-Priori برای کاهش فضای جستجو است.

---

## داده‌های مورد استفاده

داده‌های ورودی شامل ۴ تراکنش به شرح زیر است:

| TID  | Date       | Items Bought      |
| :--- | :--------- | :---------------- |
| T1   | 10-15-99   | {K, A, D, B}      |
| T2   | 10-15-99   | {D, A, C, E, B}   |
| T3   | 10-19-99   | {C, A, B, E}      |
| T4   | 10-22-99   | {B, A, D}         |

---

## اجرای گام به گام الگوریتم A-Priori

### گذر اول (Pass 1): یافتن مجموعه‌های پرتکرار با اندازه ۱ (L1)

در این مرحله، پشتیبانی هر قلم منفرد محاسبه می‌شود:

* **{K}**: ۱
* **{A}**: ۴
* **{D}**: ۳
* **{B}**: ۴
* **{C}**: ۲
* **{E}**: ۲

اقلامی که پشتیبانی آن‌ها حداقل ۳ است (min\_sup = 3)، پرتکرار محسوب می‌شوند.

**L1 = {{A}, {D}, {B}}**

---

### گذر دوم (Pass 2): یافتن مجموعه‌های پرتکرار با اندازه ۲ (L2)

بر اساس L1 = {{A}, {D}, {B}}، مجموعه‌های کاندید اندازه ۲ (C2) تولید می‌شوند. این کاندیداها تنها شامل جفت‌هایی هستند که هر دو قلم آن‌ها در L1 وجود داشته باشد.

**C2 = {{A, D}, {A, B}, {D, B}}**

پشتیبانی هر کاندید در C2 با مرور تراکنش‌ها محاسبه می‌شود:

* **{A, D}**: T1, T2, T4 $\rightarrow$ پشتیبانی = ۳
* **{A, B}**: T1, T2, T3, T4 $\rightarrow$ پشتیبانی = ۴
* **{D, B}**: T1, T2, T4 $\rightarrow$ پشتیبانی = ۳

مجموعه‌هایی که پشتیبانی آن‌ها حداقل ۳ است، به L2 اضافه می‌شوند.

**L2 = {{A, D}, {A, B}, {D, B}}**

---

### گذر سوم (Pass 3): یافتن مجموعه‌های پرتکرار با اندازه ۳ (L3)

برای تولید مجموعه‌های کاندید اندازه ۳ (C3)، از L2 استفاده می‌شود. یک مجموعه با اندازه ۳ تنها در صورتی کاندید می‌شود که تمام زیرمجموعه‌های اندازه ۲ آن در L2 حضور داشته باشند.

* تنها مجموعه‌ای با اندازه ۳ که تمام زیرمجموعه‌های اندازه ۲ آن (یعنی {A, D}, {A, B}, {D, B}) در L2 وجود دارند، **{A, D, B}** است.

**C3 = {{A, D, B}}**

پشتیبانی {A, D, B} با مرور تراکنش‌ها محاسبه می‌شود:

* **{A, D, B}**: T1, T2, T4 $\rightarrow$ پشتیبانی = ۳

مجموعه‌ای که پشتیبانی آن حداقل ۳ است، به L3 اضافه می‌شود.

**L3 = {{A, D, B}}**

---

### گذر چهارم (Pass 4): یافتن مجموعه‌های پرتکرار با اندازه ۴

برای تولید مجموعه‌های کاندید اندازه ۴ (C4)، از L3 استفاده می‌شود. از آنجایی که L3 تنها شامل یک مجموعه ({A, D, B}) است، امکان تشکیل هیچ مجموعه کاندید با اندازه ۴ که تمام زیرمجموعه‌های اندازه ۳ آن در L3 باشند، وجود ندارد.

**C4 = {} (مجموعه تهی)**

---

## پایان الگوریتم

از آنجایی که `C4` تهی است، به این معنی است که هیچ مجموعه پرتکراری با اندازه ۴ یا بزرگتر وجود ندارد. بنابراین، الگوریتم متوقف می‌شود.

---

## مجموعه‌های پرتکرار نهایی

مجموعه تمام مجموعه‌های پرتکرار، اجتماع `L1`، `L2` و `L3` است:

**Frequent Itemsets = L1 ∪ L2 ∪ L3**

**Frequent Itemsets = {{A}, {D}, {B}, {A, D}, {A, B}, {D, B}, {A, D, B}}**

---

**تمام مجموعه‌های پرتکرار یافت شده با `min_sup = 60%` (حداقل پشتیبانی ۳) عبارتند از:**

* **{A}**
* **{D}**
* **{B}**
* **{A, D}**
* **{A, B}**
* **{D, B}**
* **{A, D, B}**