
---
# تحلیل آستانه (Threshold) برای تابع S-curve در LSH

این سند به بررسی **آستانه شباهت ژاکارد (Jaccard similarity)** می‌پردازد که در آن، احتمال انتخاب دو سند به عنوان یک جفت کاندید در تکنیک Locality-Sensitive Hashing (LSH) برای امضاهای Minhash برابر با 0.5 می‌شود. تابع **S-curve** به شکل $1 - (1 - s^r)^b$ این احتمال را مدل می‌کند، جایی که **$s$** شباهت ژاکارد، **$b$** تعداد باندها (bands) و **$r$** تعداد سطرها (rows) در هر باند است.

### محاسبه آستانه دقیق

برای یافتن آستانه دقیق $s$ که در آن احتمال برابر با 0.5 می‌شود، معادله $1 - (1 - s^r)^b = \frac{1}{2}$ را حل می‌کنیم:

1.  $\frac{1}{2} = (1 - s^r)^b$
2.  با گرفتن ریشه $b$-ام از طرفین:
    $$(\frac{1}{2})^{1/b} = 1 - s^r$$
3.  با جابه‌جایی $s^r$:
    $$s^r = 1 - (\frac{1}{2})^{1/b}$$
4.  در نهایت، با گرفتن ریشه $r$-ام از طرفین، فرمول آستانه دقیق $s$ به دست می‌آید:
    $$s = (1 - (\frac{1}{2})^{1/b})^{1/r}$$

---

### مقایسه آستانه دقیق و تقریبی

در ادامه، محاسبات را برای هر یک از جفت‌های $(r, b)$ مشخص شده در تمرین 3.4.1 انجام داده و نتایج را با تخمین ساده $(1/b)^{1/r}$ مقایسه می‌کنیم:

---

#### حالت اول: $r = 3$ و $b = 10$

* **آستانه دقیق:**
    $s = (1 - (\frac{1}{2})^{1/10})^{1/3}$
    $s \approx (1 - 0.93303)^{1/3}$
    $s \approx (0.06697)^{1/3}$
    $s \approx \mathbf{0.406}$

* **آستانه تقریبی:**
    $s \approx (1/10)^{1/3}$
    $s \approx (0.1)^{1/3}$
    $s \approx \mathbf{0.464}$

* **مقایسه:** آستانه دقیق ($0.406$) **کمتر** از آستانه تقریبی ($0.464$) است.

---

#### حالت دوم: $r = 6$ و $b = 20$

* **آستانه دقیق:**
    $s = (1 - (\frac{1}{2})^{1/20})^{1/6}$
    $s \approx (1 - 0.96594)^{1/6}$
    $s \approx (0.03406)^{1/6}$
    $s \approx \mathbf{0.522}$

* **آستانه تقریبی:**
    $s \approx (1/20)^{1/6}$
    $s \approx (0.05)^{1/6}$
    $s \approx \mathbf{0.546}$

* **مقایسه:** آستانه دقیق ($0.522$) **کمتر** از آستانه تقریبی ($0.546$) است. لازم به ذکر است، در Example 3.11 منابع بیان می‌کنند که برای $b=20$ و $r=5$، آستانه کمی بیشتر از 0.5 است. آستانه دقیق محاسبه شده برای این حالت ($r=5, b=20$) برابر با $(1 - (1/2)^{1/20})^{1/5} \approx (1 - 0.96594)^{1/5} \approx (0.03406)^{1/5} \approx 0.506$ است که با این توضیحات سازگار است.

---

#### حالت سوم: $r = 5$ و $b = 50$

* **آستانه دقیق:**
    $s = (1 - (\frac{1}{2})^{1/50})^{1/5}$
    $s \approx (1 - 0.98614)^{1/5}$
    $s \approx (0.01386)^{1/5}$
    $s \approx \mathbf{0.435}$

* **آستانه تقریبی:**
    $s \approx (1/50)^{1/5}$
    $s \approx (0.02)^{1/5}$
    $s \approx \mathbf{0.457}$

* **مقایسه:** آستانه دقیق ($0.435$) **کمتر** از آستانه تقریبی ($0.457$) است.

### نتیجه‌گیری نهایی

برای هر سه جفت $(r, b)$ بررسی شده، آستانه دقیق شباهت که در آن احتمال کاندید شدن به $0.5$ می‌رسد، **همواره کمتر از** آستانه تقریبی $(1/b)^{1/r}$ است. این نشان می‌دهد که تخمین ساده $(1/b)^{1/r}$ تمایل دارد که آستانه واقعی را، یعنی جایی که احتمال کاندید شدن دقیقاً $0.5$ است، **بیش‌برآورد (overestimate)** کند.

با این حال، همانطور که منابع مربوط به LSH اشاره می‌کنند، این تخمین $(1/b)^{1/r}$ به عنوان یک نقطه تقریب "تقریباً" در جایی که منحنی S بیشترین شیب را دارد، مفید است. این فرمول به عنوان یک راهنمای عملی برای انتخاب پارامترهای $r$ و $b$ بر اساس آستانه شباهت مطلوب $t$ (که در آن $t \approx (1/b)^{1/r}$) ارائه می‌شود و به ما کمک می‌کند تا به سرعت ترکیب‌های مناسب $r$ و $b$ را برای یک سطح شباهت هدف، شناسایی کنیم.




---
## تمرین 3.4.3: تقریب منحنی S در شرایط خاص

**"با استفاده از تکنیک‌های توضیح داده شده در بخش 1.3.5، منحنی S، $1 - (1 - s^r)^b$ را در حالتی که $s^r$ بسیار کوچک است، تقریب بزنید."**

---
## تحلیل و تقریب منحنی S در LSH (بر اساس تمرین 3.4.3)

مطابق با تمرین 3.4.3 و بخش‌های مرتبط در منابع، هدف این است که تابع **S-curve** به شکل $1 - (1 - s^r)^b$ را زمانی که $s^r$ بسیار کوچک است، با استفاده از روش‌های توضیح داده شده در بخش 1.3.5 تقریب بزنیم.

تابع $1 - (1 - s^r)^b$ در تکنیک **Locality-Sensitive Hashing (LSH)** برای امضاهای مین هش (Minhash Signatures) بیانگر احتمال اینکه دو سند با شباهت ژاکارد $s$ به عنوان یک جفت کاندید در نظر گرفته شوند، است. در این فرمول، $b$ تعداد نوارها (bands) و $r$ تعداد سطرها (rows) در هر نوار است.

### تکنیک تقریب (بر اساس بخش 1.3.5)

بخش 1.3.5 منابع، تکنیک‌هایی را برای تقریب عبارات توانی مانند $(1 + a)^b$ یا $(1 - a)^b$ زمانی که $a$ کوچک است (و $b$ می‌تواند بزرگ باشد) توضیح می‌دهد. بر اساس این بخش:

* زمانی که $a$ یک عدد کوچک (مثبت یا منفی) است و $b$ بزرگ است، $(1 + a)^b$ تقریباً برابر با $e^{ab}$ است.
* به طور مشابه، زمانی که $a$ کوچک و مثبت است و $b$ بزرگ است، $(1 - a)^b$ تقریباً برابر با $e^{-ab}$ است.

این تقریب بر اساس حدی مانند $(1 - \frac{1}{x})^x$ بنا شده است که وقتی $x$ به بی‌نهایت میل می‌کند، به $\frac{1}{e}$ نزدیک می‌شود.

### تقریب منحنی S

در فرمول منحنی S، عبارت $(1 - s^r)^b$ وجود دارد. این عبارت دقیقاً شکل $(1 - a)^b$ را دارد، که در اینجا $a$ برابر با $s^r$ است. فرض تمرین این است که $s^r$ بسیار کوچک است. بنابراین، ما می‌توانیم از تقریبی که در بخش 1.3.5 توضیح داده شده است، استفاده کنیم:

$$(1 - s^r)^b \approx e^{-(s^r)b} = e^{-bs^r}$$

با جایگزینی این تقریب در فرمول اصلی منحنی S، تقریب منحنی S را زمانی که $s^r$ بسیار کوچک است، به دست می‌آوریم:

$$1 - (1 - s^r)^b \approx 1 - e^{-bs^r}$$

این تقریب نشان می‌دهد که برای مقادیر کوچک شباهت $s$ (به گونه‌ای که $s^r$ کوچک باشد)، احتمال کاندید شدن جفت به صورت نمایی بر حسب $bs^r$ افزایش می‌یابد.

---

**توجه:** اگر حاصل‌ضرب $bs^r$ نیز بسیار کوچک باشد، می‌توان از بسط تیلور تابع $e^x$ حول $x=0$ (که برای $x$ کوچک، $e^x \approx 1 + x$ است) استفاده کرد. در این حالت، با قرار دادن $x = -bs^r$، خواهیم داشت:

$e^{-bs^r} \approx 1 + (-bs^r) = 1 - bs^r$

که منجر به یک تقریب ساده‌تر برای منحنی S می‌شود:

$1 - (1 - bs^r) = bs^r$

اما تقریب اصلی و دقیق‌تر بر اساس تکنیک بخش 1.3.5 که برای $b$ بزرگ نیز کاربرد دارد، همان $1 - e^{-bs^r}$ است.


## ترجمه مسئله

تمرین 3.4.4: فرض کنید می‌خواهیم LSH (Locality-Sensitive Hashing) را با استفاده از MapReduce پیاده‌سازی کنیم. به طور خاص، فرض کنید تکه‌های ماتریس امضا شامل ستون‌ها هستند، و عناصر به صورت جفت‌های کلید-مقدار هستند که در آن **کلید شماره ستون** و **مقدار خود امضا است (یعنی یک بردار از مقادیر)**.

(الف) نشان دهید چگونه می‌توان سطل‌ها (buckets) را برای تمام نوارها (bands) به عنوان خروجی یک فرآیند MapReduce واحد تولید کرد. نکته: به یاد داشته باشید که یک تابع Map می‌تواند چندین جفت کلید-مقدار را از یک عنصر واحد تولید کند.

(ب) نشان دهید چگونه یک فرآیند MapReduce دیگر می‌تواند خروجی (الف) را به فهرستی از جفت‌هایی که نیاز به مقایسه دارند تبدیل کند. به طور خاص، برای هر ستون i، باید فهرستی از ستون‌های j > i وجود داشته باشد که i باید با آن‌ها مقایسه شود.

## حل مسئله

این مسئله چگونگی پیاده‌سازی فاز هش کردن حساس به مکان (LSH) از فرآیند یافتن اقلام مشابه با استفاده از چارچوب MapReduce را شرح می‌دهد، با فرض اینکه ماتریس امضا قبلاً محاسبه شده و به صورت ستون‌ها (هر ستون نماینده امضای یک سند است) تکه‌تکه شده است.

تکنیک LSH برای امضاهای مین هش شامل تقسیم ماتریس امضا به `b` نوار (bands) است که هر نوار شامل `r` سطر است (به طوری که `br` برابر با طول امضا باشد). سپس، برای هر نوار، بخش مربوطه از امضای هر ستون (برداری به طول `r`) به یک سطل هش می‌شود. ستون‌هایی که در **حداقل یک نوار** به یک سطل یکسان هش می‌شوند، به عنوان جفت کاندید در نظر گرفته می‌شوند.

### (الف) تولید سطل‌ها برای تمام نوارها با یک فرآیند MapReduce

هدف این بخش این است که با استفاده از یک فرآیند MapReduce، ستون‌ها را بر اساس نواری که در آن قرار دارند و سطل هشی که در آن نوار به آن اختصاص داده شده‌اند، گروه‌بندی کنیم. ورودی فرآیند MapReduce جفت‌های کلید-مقدار هستند که کلید شماره ستون و مقدار امضای آن ستون است.

1.  **تابع Map:**
    *   تابع Map یک جفت (شماره\_ستون، امضا) را به عنوان ورودی دریافت می‌کند. امضا یک بردار از `n = br` مقدار است.
    *   تابع Map باید روی `b` نوار تکرار شود.
    *   برای هر نوار `k` (از 0 تا `b-1`):
        *   بخش مربوط به نوار `k` از امضا را استخراج کنید. این بخش شامل سطرهای `k*r` تا `(k+1)*r - 1` از امضا است. این یک بردار به طول `r` است.
        *   این بردار به طول `r` را با استفاده از یک تابع هش (که می‌تواند برای هر نوار متفاوت باشد یا از پارامتر نوار استفاده کند) به یک شماره سطل هش کنید. فرض کنید این تابع هش `HashBand(sub_signature, band_number)` است.
        *   یک جفت کلید-مقدار تولید کنید (emit): کلید باید نوار و شماره سطل را به طور منحصر به فرد مشخص کند (مثلاً یک جفت `(شماره_نوار, شماره_سطل)`). مقدار باید شماره ستون اصلی باشد.
    *   **خلاصه تابع Map:**

    ```pseudocode
    map(column_id, signature):
      // signature is a vector of length n = b * r
      for band_number from 0 to b-1:
        // Extract the sub-signature for the current band
        sub_signature = signature[band_number * r ... (band_number + 1) * r - 1]

        // Hash the sub-signature for this band
        bucket_id = HashBand(sub_signature, band_number)

        // Emit the band and bucket as key, and column_id as value
        emit((band_number, bucket_id), column_id)
    ```

2.  **گروه‌بندی بر اساس کلید:**
    *   سیستم MapReduce به طور خودکار خروجی تمام توابع Map را بر اساس کلید گروه‌بندی می‌کند.
    *   برای هر کلید منحصر به فرد `(شماره_نوار, شماره_سطل)`، سیست یک لیست از تمام شماره ستون‌هایی که به آن کلید هش شده‌اند را جمع‌آوری می‌کند.

3.  **تابع Reduce:**
    *   تابع Reduce یک جفت (کلید، لیست\_مقادیر) را به عنوان ورودی دریافت می‌کند، که در آن کلید `(شماره_نوار, شماره_سطل)` و لیست\_مقادیر فهرستی از `column_id`ها است که در آن نوار و سطل خاص قرار گرفته‌اند.
    *   ستون‌هایی که در `list_of_column_ids` ظاهر می‌شوند، همگی در همان نوار و سطل یکسان هش شده‌اند و بنابراین جفت کاندید هستند.
    *   تابع Reduce می‌تواند این لیست ستون‌ها را به عنوان خروجی خود تولید کند، شاید همراه با کلید برای شناسایی سطل.
    *   **خلاصه تابع Reduce:**

    ```pseudocode
    reduce((band_number, bucket_id), list_of_column_ids):
      // list_of_column_ids contains all column IDs that hashed
      // to the same bucket_id in band_number.
      // These are the candidate columns for this specific band/bucket.

      // Output the bucket content, identified by band and bucket ID
      emit((band_number, bucket_id), list_of_column_ids)
    ```
    خروجی کلی این مرحله MapReduce، مجموعه‌ای از سطل‌ها است که هر سطل شامل فهرستی از ستون‌هایی است که در یک نوار و سطل خاص یکسان بوده‌اند.

### (ب) تبدیل خروجی سطل به فهرستی از جفت‌های کاندید برای مقایسه با یک فرآیند MapReduce دیگر

هدف این بخش این است که خروجی مرحله قبل MapReduce را بگیریم (که سطل‌ها هستند) و آن را به فهرستی از جفت‌های ستون منحصر به فرد `(i, j)` تبدیل کنیم که `i < j` و این جفت‌ها به عنوان کاندید شناسایی شده‌اند (یعنی در حداقل یک سطل با هم ظاهر شده‌اند).

1.  **تابع Map (مرحله دوم):**
    *   ورودی این تابع Map، خروجی تابع Reduce از مرحله قبلی است: یک جفت `((شماره_نوار, شماره_سطل), لیست_ستون‌ها)`.
    *   اگر `لیست_ستون‌ها` شامل بیش از یک ستون باشد، به این معنی است که چندین ستون در همان سطل در آن نوار خاص قرار گرفته‌اند و بنابراین باید به عنوان جفت کاندید در نظر گرفته شوند.
    *   تابع Map باید از بین تمام ستون‌های موجود در `لیست_ستون‌ها`، تمام جفت‌های ممکن `(i, j)` را تولید کند به شرطی که `i < j`.
    *   برای هر جفت `(i, j)` که `i < j` و هر دو `i` و `j` در `لیست_ستون‌ها` هستند، یک جفت کلید-مقدار تولید کنید. کلید باید خود جفت `(i, j)` باشد (در ترتیب متعارف، مثلاً `(min(i, j), max(i, j))`). مقدار می‌تواند هر چیز ساده‌ای مانند 1 باشد.
    *   **خلاصه تابع Map:**

    ```pseudocode
    map((band_number, bucket_id), list_of_column_ids):
      // list_of_column_ids contains columns in a specific bucket
      column_list = list_of_column_ids

      // Emit all unique pairs of columns (i, j) from this list, with i < j
      for each column_i in column_list:
        for each column_j in column_list:
          if column_i < column_j:
            // Use the pair (i, j) as the key (in canonical order)
            // The value (e.g., 1) indicates that this pair was found as a candidate
            emit((column_i, column_j), 1)
    ```

2.  **گروه‌بندی بر اساس کلید (مرحله دوم):**
    *   سیستم MapReduce خروجی تمام توابع Map را بر اساس کلید گروه‌بندی می‌کند.
    *   برای هر جفت ستون `(i, j)` که در حداقل یک سطل در مرحله Map قبلی ظاهر شده‌اند، سیستمی یک لیست از مقادیر 1 را جمع‌آوری می‌کند (هر 1 نشان‌دهنده این است که این جفت در یک سطل خاص با هم ظاهر شده‌اند).

3.  **تابع Reduce (مرحله دوم):**
    *   تابع Reduce یک جفت (کلید، لیست\_مقادیر) را به عنوان ورودی دریافت می‌کند، که در آن کلید یک جفت ستون `(i, j)` با `i < j` است و لیست\_مقادیر فهرستی از مقادیر (مثلاً 1) است که نشان می‌دهد این جفت چند بار به عنوان کاندید در سطل‌های مختلف ظاهر شده است.
    *   وجود این جفت `(i, j)` به عنوان یک کلید در ورودی تابع Reduce کافی است تا بدانیم این یک جفت کاندید است.
    *   تابع Reduce به سادگی این جفت `(i, j)` را به عنوان خروجی خود تولید می‌کند. لیست مقادیر مورد نیاز نیست.
    *   **خلاصه تابع Reduce:**

    ```pseudocode
    reduce((column_i, column_j), list_of_values):
      // The presence of this key means columns column_i and column_j
      // were found in the same bucket in at least one band.
      // This pair is a candidate pair.

      // Output the candidate pair (i, j), ensuring i < j
      // The key itself is (column_i, column_j) with column_i < column_j
      emit(column_i, column_j)
    ```
    خروجی کلی این مرحله MapReduce، فهرستی از تمام جفت‌های ستون منحصر به فرد `(i, j)` است که `i < j` و به عنوان جفت کاندید توسط LSH شناسایی شده‌اند و نیاز به مقایسه شباهت واقعی دارند.

این دو مرحله MapReduce با هم، فرآیند LSH را پیاده‌سازی می‌کنند: مرحله اول ستون‌ها را بر اساس محتوای نوارهایشان در سطل‌ها سازماندهی می‌کند و مرحله دوم تمام جفت‌های ستون‌هایی را که در هر سطل (و نوار) هم‌پوشانی دارند، جمع‌آوری کرده و فهرست نهایی جفت‌های کاندید برای مقایسه را تولید می‌کند.
